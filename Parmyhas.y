-- This Happy file was machine-generated by the BNF converter
{
module Parmyhas where
import Absmyhas
import Lexmyhas
import ErrM
}

%name pModule Module
%name pTdef Tdef
%name pListTdef ListTdef
%name pMaybeTy MaybeTy
%name pCdef Cdef
%name pListTyt ListTyt
%name pTyt Tyt
%name pListCdef ListCdef
%name pVdefg Vdefg
%name pListVdefg ListVdefg
%name pVdef Vdef
%name pListVdef ListVdef
%name pExp2 Exp2
%name pExp1 Exp1
%name pExp Exp
%name pBind Bind
%name pListBind ListBind
%name pAlt Alt
%name pListAlt ListAlt
%name pVbind Vbind
%name pListVbind ListVbind
%name pTbind Tbind
%name pListTbind ListTbind
%name pATbind ATbind
%name pListATbind ListATbind
%name pTy2 Ty2
%name pTy1 Ty1
%name pTy Ty
%name pKind1 Kind1
%name pKind Kind
%name pLit Lit
%name pQualIdent QualIdent

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '%module' { PT _ (TS "%module") }
 '%data' { PT _ (TS "%data") }
 '=' { PT _ (TS "=") }
 '{' { PT _ (TS "{") }
 '}' { PT _ (TS "}") }
 '%newtype' { PT _ (TS "%newtype") }
 ';' { PT _ (TS ";") }
 '%rec' { PT _ (TS "%rec") }
 '::' { PT _ (TS "::") }
 '@' { PT _ (TS "@") }
 '\\' { PT _ (TS "\\") }
 '->' { PT _ (TS "->") }
 '%let' { PT _ (TS "%let") }
 '%in' { PT _ (TS "%in") }
 '%case' { PT _ (TS "%case") }
 '%of' { PT _ (TS "%of") }
 '%coerce' { PT _ (TS "%coerce") }
 '%noete' { PT _ (TS "%noete") }
 '%external' { PT _ (TS "%external") }
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }
 '%_' { PT _ (TS "%_") }
 '%forall' { PT _ (TS "%forall") }
 '.' { PT _ (TS ".") }
 '*' { PT _ (TS "*") }
 '#' { PT _ (TS "#") }
 '?' { PT _ (TS "?") }

L_ident  { PT _ (TV $$) }
L_quoted { PT _ (TL $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
String  :: { String }  : L_quoted { $1 }
Integer :: { Integer } : L_integ  { (read $1) :: Integer }
Double  :: { Double }  : L_doubl  { (read $1) :: Double }
Char    :: { Char }    : L_charac { (read $1) :: Char }

Module :: { Module }
Module : '%module' Ident ListTdef ListVdefg { Module $2 (reverse $3) (reverse $4) } 


Tdef :: { Tdef }
Tdef : '%data' QualIdent ListTbind '=' '{' ListCdef '}' { Data $2 (reverse $3) $6 } 
  | '%newtype' QualIdent ListTbind MaybeTy { Newtype $2 (reverse $3) $4 }


ListTdef :: { [Tdef] }
ListTdef : {- empty -} { [] } 
  | ListTdef Tdef ';' { flip (:) $1 $2 }


MaybeTy :: { MaybeTy }
MaybeTy : '=' Ty { JustTy $2 } 
  | {- empty -} { Noty }


Cdef :: { Cdef }
Cdef : QualIdent ListATbind ListTyt { Constr $1 (reverse $2) (reverse $3) } 


ListTyt :: { [Tyt] }
ListTyt : {- empty -} { [] } 
  | ListTyt Tyt { flip (:) $1 $2 }


Tyt :: { Tyt }
Tyt : Ty2 { TT $1 } 


ListCdef :: { [Cdef] }
ListCdef : Cdef { (:[]) $1 } 
  | Cdef ';' ListCdef { (:) $1 $3 }


Vdefg :: { Vdefg }
Vdefg : '%rec' '{' ListVdef '}' { Rec $3 } 
  | Vdef { Nonrec $1 }


ListVdefg :: { [Vdefg] }
ListVdefg : {- empty -} { [] } 
  | ListVdefg Vdefg ';' { flip (:) $1 $2 }


Vdef :: { Vdef }
Vdef : QualIdent '::' Ty '=' Exp { VdefQ $1 $3 $5 } 
  | Ident '::' Ty '=' Exp { VdefU $1 $3 $5 }


ListVdef :: { [Vdef] }
ListVdef : Vdef { (:[]) $1 } 
  | Vdef ';' ListVdef { (:) $1 $3 }


Exp2 :: { Exp }
Exp2 : Ident { Var $1 } 
  | QualIdent { Dcon $1 }
  | Lit { Litc $1 }
  | Exp1 Exp2 { App $1 $2 }
  | '(' Exp ')' { $2 }


Exp1 :: { Exp }
Exp1 : Exp1 '@' Exp2 { Appt $1 $3 } 
  | Exp2 { $1 }


Exp :: { Exp }
Exp : '\\' ListBind '->' Exp { Lams $2 $4 } 
  | '%let' Vdefg '%in' Exp { Let $2 $4 }
  | '%case' Exp2 '%of' Vbind '{' ListAlt '}' { Case $2 $4 $6 }
  | '%coerce' Ty2 Exp { Coerce $2 $3 }
  | '%noete' String Exp { Note $2 $3 }
  | '%external' String Ty { External $2 $3 }
  | Exp1 { $1 }


Bind :: { Bind }
Bind : Vbind { Vb $1 } 
  | '@' Tbind { Tb $2 }


ListBind :: { [Bind] }
ListBind : Bind { (:[]) $1 } 
  | Bind ListBind { (:) $1 $2 }


Alt :: { Alt }
Alt : QualIdent ListATbind ListVbind '->' Exp { Acon $1 (reverse $2) (reverse $3) $5 } 
  | Lit '->' Exp { Alit $1 $3 }
  | '%_' '->' Exp { Adefault $3 }


ListAlt :: { [Alt] }
ListAlt : Alt { (:[]) $1 } 
  | Alt ';' ListAlt { (:) $1 $3 }


Vbind :: { Vbind }
Vbind : '(' Ident '::' Ty ')' { Vbind $2 $4 } 


ListVbind :: { [Vbind] }
ListVbind : {- empty -} { [] } 
  | ListVbind Vbind { flip (:) $1 $2 }


Tbind :: { Tbind }
Tbind : '(' Ident '::' Kind1 ')' { TbindPair $2 $4 } 
  | Ident { TbindLift $1 }


ListTbind :: { [Tbind] }
ListTbind : {- empty -} { [] } 
  | ListTbind Tbind { flip (:) $1 $2 }


ATbind :: { ATbind }
ATbind : '@' Tbind { ATbind $2 } 


ListATbind :: { [ATbind] }
ListATbind : {- empty -} { [] } 
  | ListATbind ATbind { flip (:) $1 $2 }


Ty2 :: { Ty }
Ty2 : Ident { Tvar $1 } 
  | QualIdent { Tcon $1 }
  | '(' Ty ')' { $2 }


Ty1 :: { Ty }
Ty1 : Ty1 Ty2 { Tapp $1 $2 } 
  | Ty2 { $1 }


Ty :: { Ty }
Ty : Ty1 '->' Ty { TArrow $1 $3 } 
  | '%forall' ListTbind '.' Ty { Tforalls (reverse $2) $4 }
  | Ty1 { $1 }


Kind1 :: { Kind }
Kind1 : '*' { Klifted } 
  | '#' { Kunlifted }
  | '?' { Kopen }
  | '(' Kind ')' { $2 }


Kind :: { Kind }
Kind : Kind1 '->' Kind { Karrow $1 $3 } 
  | Kind1 { $1 }


Lit :: { Lit }
Lit : '(' Integer '::' Ty2 ')' { Lint $2 $4 } 
  | '(' Double '::' Ty2 ')' { Lrational $2 $4 }
  | '(' Char '::' Ty2 ')' { Lchar $2 $4 }
  | '(' String '::' Ty2 ')' { Lstring $2 $4 }


QualIdent :: { QualIdent }
QualIdent : Ident '.' Ident { Qual $1 $3 } 



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ if null ts then [] else (" before " ++ unwords (map prToken (take 4 ts)))

myLexer = tokens
}

